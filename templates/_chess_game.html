<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
    <!-- Chess Board -->
    <div class="lg:col-span-2">
        <div class="card p-6">
            <div id="chessboard" class="mx-auto" style="width: 100%; max-width: 600px;"></div>
        </div>
    </div>

    <!-- Game Controls -->
    <div class="space-y-6">
        <!-- Game Mode -->
        <div class="card p-6">
            <h3 class="text-xl font-bold mb-4">Game Mode</h3>
            <div class="space-y-3">
                <label class="flex items-center">
                    <input type="radio" name="gameMode" value="ai" checked class="mr-2">
                    <span>vs Computer</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="gameMode" value="multiplayer" class="mr-2">
                    <span>2 Player Local</span>
                </label>
                <label class="flex items-center">
                    <input type="radio" name="gameMode" value="remote" class="mr-2">
                    <span>2 Player Remote</span>
                </label>
            </div>
        </div>

        <!-- Remote Game Setup -->
        <div class="card p-6 hidden" id="remoteSetupPanel">
            <h3 class="text-xl font-bold mb-4">Remote Game</h3>
            <div id="remoteSetup" class="space-y-3">
                <p class="text-sm text-gray-600 mb-3">You will play as <strong>White</strong> (Player 1)</p>
                <button onclick="createRemoteGame()" class="btn btn-primary w-full">
                    <i class="fa-solid fa-chess-king mr-2"></i>Start New Remote Game
                </button>
            </div>
            <div id="remoteWaiting" class="hidden space-y-3">
                <p class="text-sm font-semibold text-green-600 mb-2">Share this URL with your opponent:</p>
                <div class="flex gap-2">
                    <input type="text" id="shareUrl" readonly class="flex-1 p-2 border rounded bg-gray-50 text-sm" onclick="this.select()">
                    <button onclick="copyShareUrl()" class="btn btn-primary">
                        <i class="fa-solid fa-copy"></i>
                    </button>
                </div>
                <p class="text-xs text-gray-500">Your opponent will play as <strong>Black</strong> (Player 2)</p>
                <div id="opponentConnected" class="hidden">
                    <p class="text-sm font-semibold text-blue-600 mt-2">Opponent connected! Game starting...</p>
                </div>
            </div>
        </div>

        <!-- AI Difficulty -->
        <div class="card p-6" id="difficultyPanel">
            <h3 class="text-xl font-bold mb-4">Difficulty</h3>
            <select id="difficulty" class="w-full p-2 border rounded">
                <option value="1">Beginner</option>
                <option value="2" selected>Easy</option>
                <option value="3">Medium</option>
                <option value="4">Hard</option>
                <option value="5">Expert</option>
            </select>
        </div>

        <!-- Player Colors (hidden for remote games) -->
        <div class="card p-6" id="colorPanel">
            <h3 class="text-xl font-bold mb-4">You Play As</h3>
            <div class="flex gap-3">
                <button onclick="startNewGame('white')" class="btn btn-primary flex-1">
                    <i class="fa-solid fa-chess-king mr-2"></i>White
                </button>
                <button onclick="startNewGame('black')" class="btn flex-1">
                    <i class="fa-solid fa-chess-king mr-2"></i>Black
                </button>
            </div>
        </div>

        <!-- Remote Player Info (shown for remote games) -->
        <div class="card p-6 hidden" id="remotePlayerInfo">
            <h3 class="text-xl font-bold mb-4">Your Color</h3>
            <div class="text-center">
                <div id="playerColorDisplay" class="text-2xl font-bold mb-2"></div>
                <p class="text-sm text-gray-600">Auto-assigned for this game</p>
            </div>
        </div>

        <!-- Game Status -->
        <div class="card p-6">
            <h3 class="text-xl font-bold mb-4">Status</h3>
            <div id="status" class="text-center">
                <p class="mb-2"><strong>Turn:</strong> <span id="turn">White</span></p>
                <p id="checkStatus" class="text-red-600 font-bold hidden">Check!</p>
                <p id="pendingStatus" class="text-orange-600 font-semibold text-sm hidden mt-2">Move pending - click Complete to submit</p>
                <p id="gameOver" class="text-green-600 font-bold hidden"></p>
            </div>
        </div>

        <!-- Move History -->
        <div class="card p-6">
            <h3 class="text-xl font-bold mb-4">Moves</h3>
            <div id="moveHistory" class="max-h-48 overflow-y-auto text-sm space-y-1"></div>
        </div>

        <!-- Actions -->
        <div class="card p-6">
            <h3 class="text-xl font-bold mb-4">Actions</h3>
            <div class="space-y-2">
                <!-- Complete Move Button (only for remote games) -->
                <button id="completeMoveBtn" onclick="completeMyMove()" class="btn btn-primary w-full hidden">
                    <i class="fa-solid fa-check mr-2"></i>Complete My Move
                </button>
                <button onclick="undoMove()" class="btn w-full">
                    <i class="fa-solid fa-undo mr-2"></i>Undo Move
                </button>
                <button onclick="resetGame()" class="btn w-full">
                    <i class="fa-solid fa-rotate-right mr-2"></i>New Game
                </button>
            </div>
        </div>
    </div>
</div>

<style>
    .chessboard-wrapper { position: relative; }
    #chessboard { width: 100%; }
    .square {
        float: left;
        width: 12.5%;
        padding-bottom: 12.5%;
        position: relative;
        cursor: pointer;
    }
    .square.light { background-color: #f0d9b5; }
    .square.dark { background-color: #b58863; }
    .square.highlight { background-color: #baca44 !important; }
    .square.selected { background-color: #f7f769 !important; }
    .piece {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 300%;
        user-select: none;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script>
    let game = new Chess();
    let playerColor = 'white';
    let gameMode = 'ai';
    let selectedSquare = null;
    let aiDifficulty = 2;

    // Remote game variables
    let remoteGameId = null;
    let isRemoteGame = false;
    let pollInterval = null;
    let lastMoveCount = 0;
    let playerToken = null;
    let pendingMove = null;  // Track move waiting to be confirmed

    // Get or create player token
    function getPlayerToken() {
        if (!playerToken) {
            playerToken = localStorage.getItem('chess_player_token');
            if (!playerToken) {
                // Generate a unique token for this browser/tab using crypto.randomUUID
                if (crypto && crypto.randomUUID) {
                    playerToken = crypto.randomUUID();
                } else {
                    // Fallback with more randomness
                    playerToken = Math.random().toString(36).substring(2) +
                                  Math.random().toString(36).substring(2) +
                                  Date.now().toString(36);
                }
                localStorage.setItem('chess_player_token', playerToken);
                console.log('[CHESS] Generated new player token:', playerToken.substring(0, 8) + '...');
            }
        }
        return playerToken;
    }

    // Piece symbols
    const pieces = {
        'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
        'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };

    // Remote game functions
    async function createRemoteGame() {
        try {
            console.log('[CHESS] Creating game as WHITE (Player 1) with token:', getPlayerToken().substring(0, 8) + '...');
            const response = await fetch('/api/chess/create', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player_token: getPlayerToken()
                })
            });

            const data = await response.json();
            console.log('[CHESS] Create response:', data);

            if (data.success) {
                remoteGameId = data.game_id;
                playerColor = 'white';  // Creator is always white
                isRemoteGame = true;

                console.log('[CHESS] Game created with ID:', remoteGameId);

                // Show share URL
                const shareUrl = `${window.location.origin}/games/chess?game_id=${remoteGameId}`;
                document.getElementById('shareUrl').value = shareUrl;
                document.getElementById('remoteSetup').classList.add('hidden');
                document.getElementById('remoteWaiting').classList.remove('hidden');

                console.log('[CHESS] Share URL:', shareUrl);

                // Show/hide appropriate panels for remote game
                document.getElementById('colorPanel').classList.add('hidden');
                document.getElementById('difficultyPanel').classList.add('hidden');
                document.getElementById('remotePlayerInfo').classList.remove('hidden');
                document.getElementById('playerColorDisplay').textContent = 'White';
                document.getElementById('playerColorDisplay').style.color = '#000';
                document.getElementById('playerColorDisplay').style.textShadow = '0 0 3px #000';

                // Start polling for opponent
                startPolling();

                // Reset and start game with proper board orientation
                resetGame();
                initBoard();  // Reinitialize with correct orientation
            } else {
                console.error('[CHESS] Failed to create game:', data.error);
                alert('Failed to create remote game: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('[CHESS] Error creating remote game:', error);
            alert('Failed to create remote game. Please try again.');
        }
    }

    async function joinRemoteGame(gameId) {
        try {
            console.log('[CHESS] Joining game:', gameId, 'with token:', getPlayerToken().substring(0, 8) + '...');
            const response = await fetch(`/api/chess/game/${gameId}?player_token=${getPlayerToken()}`);
            const data = await response.json();

            console.log('[CHESS] Join response:', data);

            if (data.success) {
                remoteGameId = gameId;
                isRemoteGame = true;
                playerColor = data.player_color;

                console.log('[CHESS] Successfully joined as:', playerColor);

                // Load game state
                game.load(data.fen);
                lastMoveCount = data.moves.length;

                // Rebuild move history properly
                document.getElementById('moveHistory').innerHTML = '';
                for (let i = 0; i < data.moves.length; i++) {
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhiteMove = i % 2 === 0;
                    const moveText = isWhiteMove ? `${moveNum}. ${data.moves[i]}` : data.moves[i];

                    const history = document.getElementById('moveHistory');
                    if (isWhiteMove) {
                        const div = document.createElement('div');
                        div.textContent = moveText;
                        history.appendChild(div);
                    } else {
                        const lastDiv = history.lastElementChild;
                        if (lastDiv) {
                            lastDiv.textContent += ` ${moveText}`;
                        }
                    }
                }

                // Show/hide appropriate panels for remote game
                document.getElementById('colorPanel').classList.add('hidden');
                document.getElementById('difficultyPanel').classList.add('hidden');
                document.getElementById('remotePlayerInfo').classList.remove('hidden');
                document.getElementById('playerColorDisplay').textContent = playerColor.charAt(0).toUpperCase() + playerColor.slice(1);
                document.getElementById('playerColorDisplay').style.color = playerColor === 'white' ? '#000' : '#fff';
                document.getElementById('playerColorDisplay').style.textShadow = playerColor === 'white' ? '0 0 3px #000' : '0 0 3px #fff';

                // Reinitialize board with proper orientation
                initBoard();

                // Hide remote setup panel
                document.getElementById('remoteSetupPanel').classList.add('hidden');

                // Start polling for moves
                startPolling();

                if (data.players_connected) {
                    console.log('[CHESS] Both players connected');
                }
            } else {
                console.error('[CHESS] Failed to join game:', data.error);
                alert('Failed to join game: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('[CHESS] Error joining remote game:', error);
            alert('Error joining game. Please check console for details.');
        }
    }

    async function pollGameState() {
        if (!isRemoteGame || !remoteGameId) return;

        try {
            const response = await fetch(`/api/chess/game/${remoteGameId}?player_token=${getPlayerToken()}`);
            const data = await response.json();

            if (data.success) {
                // Check if opponent connected
                if (data.players_connected) {
                    const connectedEl = document.getElementById('opponentConnected');
                    if (connectedEl && connectedEl.classList.contains('hidden')) {
                        connectedEl.classList.remove('hidden');
                    }
                }

                // Check for new moves from server
                if (data.moves.length > lastMoveCount) {
                    console.log('[CHESS] New moves detected:', data.moves.length, 'vs', lastMoveCount);
                    console.log('[CHESS] Loading FEN from server:', data.fen);

                    // Load the complete game state from server
                    game.load(data.fen);

                    console.log('[CHESS] After loading FEN - turn is now:', game.turn(), 'my color:', playerColor.charAt(0));

                    // Rebuild entire move history to keep it in sync
                    document.getElementById('moveHistory').innerHTML = '';
                    for (let i = 0; i < data.moves.length; i++) {
                        const moveNum = Math.floor(i / 2) + 1;
                        const isWhiteMove = i % 2 === 0;
                        const moveText = isWhiteMove ? `${moveNum}. ${data.moves[i]}` : data.moves[i];

                        const history = document.getElementById('moveHistory');
                        if (isWhiteMove) {
                            const div = document.createElement('div');
                            div.textContent = moveText;
                            history.appendChild(div);
                        } else {
                            const lastDiv = history.lastElementChild;
                            if (lastDiv) {
                                lastDiv.textContent += ` ${moveText}`;
                            }
                        }
                    }
                    document.getElementById('moveHistory').scrollTop = document.getElementById('moveHistory').scrollHeight;

                    lastMoveCount = data.moves.length;
                    updateBoard();
                }

                if (data.game_over) {
                    stopPolling();
                }
            }
        } catch (error) {
            console.error('[CHESS] Error polling game state:', error);
        }
    }

    function startPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
        }
        pollInterval = setInterval(pollGameState, 2000); // Poll every 2 seconds (reduced frequency)
    }

    function stopPolling() {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
        }
    }

    async function submitRemoteMove(move) {
        if (!isRemoteGame || !remoteGameId) return;

        try {
            const response = await fetch(`/api/chess/game/${remoteGameId}/move`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player_token: getPlayerToken(),
                    fen: game.fen(),
                    turn: game.turn(),
                    move: move.san,
                    game_over: game.game_over(),
                    result: game.game_over() ? getGameResult() : null
                })
            });

            const data = await response.json();
            if (data.success) {
                lastMoveCount++;
                pendingMove = null;
                document.getElementById('completeMoveBtn').classList.add('hidden');
                document.getElementById('pendingStatus').classList.add('hidden');
                console.log('[CHESS] Move submitted successfully');
            }
        } catch (error) {
            console.error('[CHESS] Error submitting move:', error);
        }
    }

    function completeMyMove() {
        if (!pendingMove) {
            console.log('[CHESS] No pending move to complete');
            return;
        }

        console.log('[CHESS] Completing move:', pendingMove.san);
        submitRemoteMove(pendingMove);
    }

    function getGameResult() {
        if (game.in_checkmate()) {
            return `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} wins!`;
        } else if (game.in_draw()) {
            return 'Draw!';
        } else if (game.in_stalemate()) {
            return 'Stalemate!';
        } else if (game.in_threefold_repetition()) {
            return 'Draw by repetition!';
        }
        return 'Game over!';
    }

    function copyShareUrl() {
        const urlInput = document.getElementById('shareUrl');
        urlInput.select();
        urlInput.setSelectionRange(0, 99999); // For mobile devices

        try {
            document.execCommand('copy');
            const btn = event.target.closest('button');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<i class="fa-solid fa-check"></i>';
            setTimeout(() => {
                btn.innerHTML = originalHTML;
            }, 2000);
        } catch (err) {
            console.error('Failed to copy URL:', err);
        }
    }

    function initBoard() {
        console.log('[CHESS] initBoard() called - playerColor:', playerColor, 'isRemoteGame:', isRemoteGame);
        const board = document.getElementById('chessboard');
        if (!board) {
            console.error('[CHESS] ERROR: chessboard element not found!');
            return;
        }
        board.innerHTML = '';

        // Flip board if playing as black
        const isFlipped = playerColor === 'black';
        console.log('[CHESS] Board orientation - isFlipped:', isFlipped);

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');

                // Calculate actual row/col based on orientation
                const actualRow = isFlipped ? row : row;
                const actualCol = isFlipped ? 7 - col : col;
                const actualSquareRow = isFlipped ? row + 1 : 8 - row;

                const isLight = (row + col) % 2 === 0;
                const squareName = String.fromCharCode(97 + actualCol) + actualSquareRow;

                square.className = `square ${isLight ? 'light' : 'dark'}`;
                square.dataset.square = squareName;
                square.onclick = () => handleSquareClick(squareName);

                board.appendChild(square);
            }
        }
        console.log('[CHESS] Created 64 squares with click handlers');
        updateBoard();
    }

    function updateBoard() {
        document.querySelectorAll('.square').forEach((square) => {
            // Get piece based on the square's name attribute (works for any orientation)
            const squareName = square.dataset.square;
            const piece = game.get(squareName);

            square.innerHTML = '';
            if (piece) {
                const pieceEl = document.createElement('div');
                pieceEl.className = 'piece';
                pieceEl.style.color = piece.color === 'w' ? '#fff' : '#000';
                pieceEl.style.textShadow = piece.color === 'w' ? '0 0 3px #000' : '0 0 3px #fff';
                // Use correct symbol based on piece color
                const pieceSymbol = piece.color === 'w' ? pieces[piece.type.toUpperCase()] : pieces[piece.type];
                pieceEl.textContent = pieceSymbol;
                square.appendChild(pieceEl);
            }
        });

        updateStatus();
    }

    function handleSquareClick(square) {
        if (game.game_over()) {
            console.log('[CHESS] Game is over, no moves allowed');
            return;
        }

        // For AI mode, only allow moves when it's player's turn
        if (gameMode === 'ai' && game.turn() !== playerColor.charAt(0)) {
            console.log('[CHESS] Not your turn (AI mode) - current turn:', game.turn(), 'your color:', playerColor);
            return;
        }

        // For remote mode, only allow moves when it's player's turn
        if (isRemoteGame && game.turn() !== playerColor.charAt(0)) {
            console.log('[CHESS] Not your turn (remote mode) - current turn:', game.turn(), 'your color:', playerColor, 'isRemoteGame:', isRemoteGame);
            return;
        }

        console.log('[CHESS] Click allowed - turn:', game.turn(), 'your color:', playerColor, 'square:', square);

        // Clear previous highlights
        document.querySelectorAll('.square').forEach(s => {
            s.classList.remove('selected', 'highlight');
        });

        if (selectedSquare) {
            // Try to make move
            const move = game.move({
                from: selectedSquare,
                to: square,
                promotion: 'q' // always promote to queen for simplicity
            });

            if (move) {
                updateBoard();
                addMoveToHistory(move);
                selectedSquare = null;

                // Handle move based on game mode
                if (isRemoteGame) {
                    // Store move as pending and show complete button
                    pendingMove = move;
                    document.getElementById('completeMoveBtn').classList.remove('hidden');
                    document.getElementById('pendingStatus').classList.remove('hidden');
                    console.log('[CHESS] Move pending confirmation:', move.san);
                } else if (gameMode === 'ai' && !game.game_over()) {
                    // AI move after a delay
                    setTimeout(makeAIMove, 500);
                }
            } else {
                // Select new piece
                selectedSquare = square;
                document.querySelector(`[data-square="${square}"]`).classList.add('selected');
                highlightLegalMoves(square);
            }
        } else {
            // Select piece
            const piece = game.get(square);
            if (piece && piece.color === game.turn()) {
                selectedSquare = square;
                document.querySelector(`[data-square="${square}"]`).classList.add('selected');
                highlightLegalMoves(square);
            }
        }
    }

    function highlightLegalMoves(square) {
        const moves = game.moves({ square, verbose: true });
        moves.forEach(move => {
            document.querySelector(`[data-square="${move.to}"]`).classList.add('highlight');
        });
    }

    function makeAIMove() {
        const moves = game.moves();
        if (moves.length === 0) return;

        // Simple AI: evaluate moves based on difficulty
        let move;
        const random = Math.random();

        if (aiDifficulty === 1 || random < 0.3) {
            // Random move for beginner
            move = moves[Math.floor(Math.random() * moves.length)];
        } else {
            // Look for captures and checks
            const captures = game.moves({ verbose: true }).filter(m => m.captured);
            const checks = game.moves({ verbose: true }).filter(m => {
                game.move(m);
                const inCheck = game.in_check();
                game.undo();
                return inCheck;
            });

            if (captures.length > 0 && random < 0.5 + (aiDifficulty * 0.1)) {
                move = captures[Math.floor(Math.random() * captures.length)].san;
            } else if (checks.length > 0 && random < 0.3 + (aiDifficulty * 0.1)) {
                move = checks[Math.floor(Math.random() * checks.length)].san;
            } else {
                move = moves[Math.floor(Math.random() * moves.length)];
            }
        }

        const result = game.move(move);
        if (result) {
            updateBoard();
            addMoveToHistory(result);
        }
    }

    function updateStatus() {
        const currentTurn = game.turn() === 'w' ? 'White' : 'Black';
        document.getElementById('turn').textContent = currentTurn;

        // Highlight whose turn it is in remote games
        if (isRemoteGame) {
            const isMyTurn = game.turn() === playerColor.charAt(0);
            const turnEl = document.getElementById('turn');
            if (isMyTurn) {
                turnEl.style.color = '#16a34a';  // green
                turnEl.style.fontWeight = 'bold';
            } else {
                turnEl.style.color = '#6b7280';  // gray
                turnEl.style.fontWeight = 'normal';
            }
        }

        document.getElementById('checkStatus').classList.toggle('hidden', !game.in_check());

        const gameOverEl = document.getElementById('gameOver');
        if (game.game_over()) {
            if (game.in_checkmate()) {
                gameOverEl.textContent = `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} wins!`;
            } else if (game.in_draw()) {
                gameOverEl.textContent = 'Draw!';
            } else if (game.in_stalemate()) {
                gameOverEl.textContent = 'Stalemate!';
            } else if (game.in_threefold_repetition()) {
                gameOverEl.textContent = 'Draw by repetition!';
            } else {
                gameOverEl.textContent = 'Game over!';
            }
            gameOverEl.classList.remove('hidden');
        } else {
            gameOverEl.classList.add('hidden');
        }
    }

    function addMoveToHistory(move) {
        const history = document.getElementById('moveHistory');
        const moveNum = Math.floor(game.history().length / 2) + 1;
        const moveText = game.turn() === 'b' ? `${moveNum}. ${move.san}` : `${move.san}`;

        if (game.turn() === 'b') {
            const div = document.createElement('div');
            div.textContent = moveText;
            history.appendChild(div);
        } else {
            const lastDiv = history.lastElementChild;
            if (lastDiv) {
                lastDiv.textContent += ` ${moveText}`;
            }
        }

        history.scrollTop = history.scrollHeight;
    }

    function undoMove() {
        // In remote games, only allow undo of pending (unconfirmed) move
        if (isRemoteGame && pendingMove) {
            game.undo();
            pendingMove = null;
            document.getElementById('completeMoveBtn').classList.add('hidden');
            document.getElementById('pendingStatus').classList.add('hidden');
            updateBoard();
            // Rebuild move history
            document.getElementById('moveHistory').innerHTML = '';
            game.history({ verbose: true }).forEach(addMoveToHistory);
            console.log('[CHESS] Pending move undone');
            return;
        }

        // For local/AI games, undo as usual
        if (!isRemoteGame) {
            game.undo();
            if (gameMode === 'ai') {
                game.undo(); // Undo AI move too
            }
            updateBoard();
            // Rebuild move history
            document.getElementById('moveHistory').innerHTML = '';
            game.history({ verbose: true }).forEach(addMoveToHistory);
        }
    }

    function resetGame() {
        game.reset();
        selectedSquare = null;
        document.getElementById('moveHistory').innerHTML = '';
        updateBoard();
    }

    function startNewGame(color) {
        playerColor = color;
        resetGame();
        if (color === 'black' && gameMode === 'ai') {
            setTimeout(makeAIMove, 500);
        }
    }

    // Event listeners
    document.querySelectorAll('input[name="gameMode"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            gameMode = e.target.value;

            // Show/hide panels based on mode
            if (gameMode === 'remote') {
                document.getElementById('difficultyPanel').style.display = 'none';
                document.getElementById('colorPanel').classList.add('hidden');
                document.getElementById('remoteSetupPanel').classList.remove('hidden');
                document.getElementById('remotePlayerInfo').classList.add('hidden');
            } else {
                document.getElementById('difficultyPanel').style.display = gameMode === 'ai' ? 'block' : 'none';
                document.getElementById('colorPanel').classList.remove('hidden');
                document.getElementById('remoteSetupPanel').classList.add('hidden');
                document.getElementById('remotePlayerInfo').classList.add('hidden');

                // Stop polling if switching away from remote mode
                stopPolling();
                isRemoteGame = false;
                remoteGameId = null;
                pendingMove = null;
                document.getElementById('completeMoveBtn').classList.add('hidden');
                document.getElementById('pendingStatus').classList.add('hidden');
            }

            resetGame();
        });
    });

    document.getElementById('difficulty').addEventListener('change', (e) => {
        aiDifficulty = parseInt(e.target.value);
    });

    // Initialize
    initBoard();

    // Check if joining an existing game via URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const gameIdParam = urlParams.get('game_id');
    if (gameIdParam) {
        // Automatically switch to remote mode and join the game
        document.querySelector('input[name="gameMode"][value="remote"]').checked = true;
        gameMode = 'remote';
        document.getElementById('difficultyPanel').style.display = 'none';
        joinRemoteGame(gameIdParam);
    }
</script>
